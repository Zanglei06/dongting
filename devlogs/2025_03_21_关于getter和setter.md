没想到今天居然要讨论一个看起来很简单的问题，java中的getter和setter现在到底有什么用？

我记得getter/setter规范最早是javabean规范引入的，和直接访问字段相比，本意是可以在方法里面干一些额外的事情。比如一个图形窗口
对象，修改它的背景色属性，可以在setter里面调用类似repaint()之类的方法直接就把背景色给换了。但并不是所有的属性都适合这么做，比如
如果要修改窗口的大小，width和height是两个属性，让用户看到窗口先变长再变宽是很奇怪的，应该同时设置，提供一个类似
`setSize(int width, int height)`这样的方法，它不是一个标准setter方法，而原来的setWidth/setHeight方法就用不上了。

今天已经很少有人用java来开发图形界面了，更多的时候，我们用javabean（这个名字可能不恰当）用来传递数据，这种类有很多名字，
DO（Data Object），VO（Value Object），DTO（Data Transfer Object），等等。总之就是一个类里面一堆private字段，
剩下所有的方法全部是getter/setter方法（最多再多个equals/hashCode）。通过getter和setter来读写私有的字段，这就叫“封装”，
以便在需要的时候，可以这些方法中加入一些额外的逻辑。但是但是，我们什么时候才会这样干？从工程上来讲，在DO/VO/DTO这些玩意里面加入业务逻辑，
怎么看都不像个好主意，反倒像是“飞线”，那定义getter/setter是不是过度设计呢？你什么时候改过一个DO里面的getter/setter方法吗？

你也可能会问，遵循传统也没见有什么坏处啊？反正现在IDE/AI自动生成这些方法，还有lombok/record等助力，也不需要多敲几下键盘。
而我的观点是，这种传统是java变得庞大和缓慢的原因之一。

java应用打包后特别大？除了依赖传递的原因以外，getter/setter为每一个jar包的变大都出了一份力。举例来说dongting的NioConfig类，
包含17个字段，生成getter/setter后，生成的class文件从2125字节变成了5848字节，这太夸张了。可以想象积少成多以后，这些无聊的方法
对整个jar包的贡献有多大。

getter/setter的另一个作用就是让程序的运行变得更慢，调用方法有额外的开销，比不上直接访问字段。JIT可能会内联这些方法，但JIT本身是有开销的，
多一堆方法要分析，启动就更缓慢，内存开销也会更多，到最后也不保证一定会内联。一次方法调用，不一定有什么开销，但也是架不住积少成多，这种调用
实在太多了。。。

直接使用字段还有额外的好处，在IDE中开发时，查找字段的引用非常方便，还可以按读或按写来过滤。如果是getter/setter的话，则需要分别查找。

那遵循传统有什么优点呢，到底什么情况下，我需要在访问方法里面添加其它代码？除了上面提到的“飞线”，我几乎想不出来，偶尔在追查问题的时候要
往里面加个日志，排查完毕以后再删掉，除此外我真的想不出来了。这点好处对于dongting这样一个追求小而快的项目来说真的不值得，
我最后还是决定按自己的想法来，但这经历了一个漫长的过程。

最开始，我只是觉得很多public的类和方法，其实是内部使用的，只是因为使用者不在同一个package，只好申明为public。JPMS能部分解决这个问题，
但它也只能按package来管理，而不能按类和方法来管理。前几年我在为了减少不必要的暴露，喜欢设计成扁平的大package，这样很多类就可以在同一个
package下，使用package private级别的访问权限。既然是内部使用，就不用通过一个方法来get/set了，反正要改随时都可以。dongting早期
的代码就是这样的。

后来我开始追求在一些核心链路上，直接访问字段来替代方法， 刚开始的时候还有点纠结，什么时候该用方法，什么时候该用字段？经过
一番长时间激烈的内心斗争（没办法，循规蹈矩的惯性力量太强大了），直到前几个用才终于想通了，管他呢，如果我判定一个字段的getter/setter肯定
是简单访问而不该有副作用，我就直接用字段。之前已经写的也改了一遍，改动的过程非常繁琐，IDE可以将对字段的方法，自动重构成使用
getter/setter方法，但反过来不行。最后也没有改完全，所以如果你在dongting项目代码中看到混用，也不必奇怪。

最后我又来制造暴论了：大部分时候Java里的getter/setter没有意义，直接用public字段就可以了，对吗？